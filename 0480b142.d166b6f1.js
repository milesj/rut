(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{53:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n(2),r=n(6),o=(n(0),n(78)),i={title:"FAQ"},s={unversionedId:"faq",id:"faq",isDocsHomePage:!1,title:"FAQ",description:"Is the DOM really not required?",source:"@site/docs/faq.md",slug:"/faq",permalink:"/docs/faq",editUrl:"https://github.com/milesj/rut/edit/master/website/docs/faq.md",version:"current",sidebar:"docs",previous:{title:"Setup",permalink:"/docs/setup"},next:{title:"Render",permalink:"/docs/api/render"}},c=[{value:"Is the DOM really not required?",id:"is-the-dom-really-not-required",children:[]},{value:"How to handle async calls during a mount or update?",id:"how-to-handle-async-calls-during-a-mount-or-update",children:[]},{value:"How to check the props of an element?",id:"how-to-check-the-props-of-an-element",children:[]},{value:"How to access component state?",id:"how-to-access-component-state",children:[]},{value:"What about Enzyme?",id:"what-about-enzyme",children:[]},{value:"What about React Testing Library?",id:"what-about-react-testing-library",children:[]}],l={rightToc:c};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"is-the-dom-really-not-required"},"Is the DOM really not required?"),Object(o.b)("p",null,"Rut itself does not require the DOM, nor does it use ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jsdom/jsdom"}),"JSDOM")," for its\nunit tests (our Jest ",Object(o.b)("inlineCode",{parentName:"p"},"testEnvironment")," is ",Object(o.b)("inlineCode",{parentName:"p"},"node"),")."),Object(o.b)("p",null,"However, if a component uses ",Object(o.b)("inlineCode",{parentName:"p"},"window"),", ",Object(o.b)("inlineCode",{parentName:"p"},"document"),", or any other browser based API, you will need the\nDOM. An alternative would be to mock these APIs, but that might be more trouble than it's worth."),Object(o.b)("h2",{id:"how-to-handle-async-calls-during-a-mount-or-update"},"How to handle async calls during a mount or update?"),Object(o.b)("p",null,"Testing async calls has been historically difficult, as you'd have to use arbitrary timers or await\na promise returning function. Rut attempts to mitigate this problem by capturing async calls and\nwaiting for them to resolve before returning a rendered result. This is typically done with the\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/api/render#renderandwait"}),Object(o.b)("inlineCode",{parentName:"a"},"renderAndWait")),",\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/api/result#updateandwait"}),Object(o.b)("inlineCode",{parentName:"a"},"Result#updateAndWait")),", and other methods like ",Object(o.b)("inlineCode",{parentName:"p"},"*AndWait"),"."),Object(o.b)("p",null,"An example of this can be found in the\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/milesj/rut/blob/master/packages/rut-dom/tests/examples/async.test.tsx"}),"official async tests"),"."),Object(o.b)("h2",{id:"how-to-check-the-props-of-an-element"},"How to check the props of an element?"),Object(o.b)("p",null,"Rut does not provide an API for directly accessing the props of an element, as it encourages bad\ntesting practices. Instead, you can use the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/matchers#toHaveProp"}),Object(o.b)("inlineCode",{parentName:"a"},"toHaveProp()"))," or\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/matchers#toHaveProps"}),Object(o.b)("inlineCode",{parentName:"a"},"toHaveProps()"))," matchers for checking props."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"interface Props {\n  children: React.ReactNode;\n  id?: string;\n}\n\nfunction PropsExample({ children, id }: Props) {\n  return <div id={id}>{children}</div>;\n}\n\n// BAD\nit('passes id down', () => {\n  const wrapper = shallow(<PropsExample id=\"foo\">Content</PropsExample>);\n\n  expect(wrapper.prop('id')).toBe('foo');\n});\n\n// GOOD\nit('passes id down', () => {\n  const { root } = render<Props>(<PropsExample id=\"foo\">Content</PropsExample>);\n\n  expect(root).toHaveProp('id', 'foo');\n});\n")),Object(o.b)("h2",{id:"how-to-access-component-state"},"How to access component state?"),Object(o.b)("p",null,"You don't! Accessing state is a code smell as it's an implementation detail. Instead, you should\ntest the result of the state change, and not the state itself."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"class StateExample extends React.Component<{}, { active: boolean }> {\n  state = {\n    active: false,\n  };\n\n  handleToggle = () => {\n    this.setState((prevState) => ({\n      active: !prevState.active,\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <span>{this.state.active ? 'Active' : 'Inactive'}</span>\n        <button type=\"button\" onClick={this.handleToggle}>\n          Toggle\n        </button>\n      </div>\n    );\n  }\n}\n\n// BAD\nit('renders active state', () => {\n  const wrapper = shallow(<StateExample />);\n\n  expect(wrapper.state('active')).toBe(false);\n\n  wrapper.find('button').simulate('click');\n\n  expect(wrapper.state('active')).toBe(true);\n});\n\n// GOOD\nit('renders active state', () => {\n  const { root } = render(<StateExample />);\n\n  expect(root).toContainNode('Inactive');\n\n  root.findOne('button').dispatch('onClick');\n\n  expect(root).toContainNode('Active');\n});\n")),Object(o.b)("h2",{id:"what-about-enzyme"},"What about Enzyme?"),Object(o.b)("p",null,Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/airbnb/enzyme"}),"Enzyme")," paved the way for React testing, but sadly, has fallen\nfrom grace over the past few years. This is compounded by the following prevalent issues:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"New React features take quite some time before landing in Enzyme (Context took almost a year!),\nresulting in consumers either not adopting new React features, or simply not testing components\nthat use new React features."),Object(o.b)("li",{parentName:"ul"},"Enzyme encourages bad testing practices and relies on implementation details. This includes direct\naccess to state, props, and component instances, simulating events on non-DOM elements, and more."),Object(o.b)("li",{parentName:"ul"},"Changes to Enzyme core must be applied to all renderer types (shallow, mount, render) and all\nReact version adapters (15, 16, etc). This is usually very tedious and problematic.")),Object(o.b)("p",null,"Rut aims to avoid these issues by utilizing the\n",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/test-renderer.html"}),"react-test-renderer")," provided by the React core team,\nand continually released alongside new React versions."),Object(o.b)("h2",{id:"what-about-react-testing-library"},"What about React Testing Library?"),Object(o.b)("p",null,Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://testing-library.com/docs/react-testing-library/intro"}),"RTL")," and Rut serve a similar purpose,\nhave similar APIs, and align on the same best practices. The major difference is that RTL requires a\nDOM and uses ",Object(o.b)("inlineCode",{parentName:"p"},"react-dom")," for tree rendering, while Rut is DOM-less and uses ",Object(o.b)("inlineCode",{parentName:"p"},"react-test-renderer"),".\nHonestly, both are great solutions, so choose the one you like best!"))}p.isMDXComponent=!0},78:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),p=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=p(n),b=a,m=d["".concat(i,".").concat(b)]||d[b]||u[b]||o;return n?r.a.createElement(m,s(s({ref:t},l),{},{components:n})):r.a.createElement(m,s({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=b;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);